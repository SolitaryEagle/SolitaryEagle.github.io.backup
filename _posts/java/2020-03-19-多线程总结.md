---
layout: post
title: Java 多线程
category: Java相关
tags: Java
---
![Java并发编程](/images/java/Java并发编程.png)
# 并发编程Bug源头
  * CPU缓存导致的可见性问题
  * 线程切换带来的原子性问题
  * 编译优化带来的有序性问题

# 死锁发生的条件
  1. 互斥，共享资源 X 和 Y 只能被一个线程占用
  2. 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X
  3. 不可抢占，其他线程不能强行抢占线程 T1 占有的资源
  4. 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待

反过来分析，也就是说只要我们破坏其中一个，就可以成功避免死锁的发生。

其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥。

# 防止死锁的办法
  1. 对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了
  2. 对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了
  3. 对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了

# Happens-Before 规则
释义: 前面一个操作的结果对后续操作是可见的
  1. 程序的顺序性规则
  2. volatile 变量规则(写 Happens-Before 读)
  3. 传递性
  4. 管程中锁的规则(解锁 Happens-Before 加锁)
  5. 线程 start() 规则(主线程启动子线程之前 Happens-Before 子线程)
  6. 线程 join() 规则(子线程 Happens-Before 主线程join子线程之后)
  
# 受保护资源和锁的关系
受保护资源和锁之间合理的关联关系应该是 N:1 的关系

## 保护没有关联关系的多个资源
用不同的锁对受保护资源进行精细化管理，能够提升性能。这种锁还有个名字，叫细粒度锁。

## 保护有关联关系的多个资源
用相同的锁

# 线程生命周期

## 通用的线程生命周期
![通用的线程生命周期](/images/java/通用的线程生命周期.png)

## Java 中线程的生命周期
![Java中的线程生命周期](/images/java/Java中的线程生命周期.png)

# 并发编程的要点
  * 封装共享变量
  * 识别共享变量间的约束条件
  * 制定并发访问策略

# 用锁的最佳实践
  1. 永远只在更新对象的成员变量时加锁
  2. 永远只在访问可变的成员变量时加锁
  3. 永远不在调用其他对象的方法时加锁

# 如何使用 Java 中的线程池
  * corePoolSize：表示线程池保有的最小线程数。有些项目很闲，但是也不能把人都撤了，至少要留 corePoolSize 个人坚守阵地。
  * maximumPoolSize：表示线程池创建的最大线程数。当项目很忙时，就需要加人，但是也不能无限制地加，最多就加到 maximumPoolSize 个人。当项目闲下来时，就要撤人了，最多能撤到 corePoolSize 个人。
  * keepAliveTime & unit：上面提到项目根据忙闲来增减人员，那在编程世界里，如何定义忙和闲呢？很简单，一个线程如果在一段时间内，都没有执行任务，说明很闲，keepAliveTime 和 unit 就是用来定义这个“一段时间”的参数。也就是说，如果一个线程空闲了keepAliveTime & unit这么久，而且线程池的线程数大于 corePoolSize ，那么这个空闲的线程就要被回收了。
  * workQueue：工作队列，和上面示例代码的工作队列同义。
  * threadFactory：通过这个参数你可以自定义如何创建线程，例如你可以给线程指定一个有意义的名字。
  * handler：通过这个参数你可以自定义任务的拒绝策略。如果线程池中所有的线程都在忙碌，并且工作队列也满了（前提是工作队列是有界队列），那么此时提交任务，线程池就会拒绝接收。至于拒绝的策略，你可以通过 handler 这个参数来指定。ThreadPoolExecutor 已经提供了以下 4 种策略。
    * CallerRunsPolicy：提交任务的线程自己去执行该任务。
    * AbortPolicy：默认的拒绝策略，会 throws RejectedExecutionException。
    * DiscardPolicy：直接丢弃任务，没有任何异常抛出。
    * DiscardOldestPolicy：丢弃最老的任务，其实就是把最早进入工作队列的任务丢弃，然后把新任务加入到工作队列。

Java 在 1.6 版本还增加了 allowCoreThreadTimeOut(boolean value) 方法，它可以让所有线程都支持超时，这意味着如果项目很闲，就会将项目组的成员都撤走。

## 使用线程池要注意些什么
  * 强烈建议使用有界队列
  * 默认拒绝策略要慎重使用









